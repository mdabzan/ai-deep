<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>OOCS AI Facial Analysis</title>

<style>
  /* ---- CSS VARIABLES ---- */
:root {
    --primary: #6366f1;
    --primary-dark: #4f46e5;
    --success: #10b981;
    --danger: #ef4444;
    --bg-dark: #0f172a;
    --bg-card-dark: #1e293b;
    --bg-light: #f8fafc;
    --bg-card-light: #ffffff;
    --text-dark: #f1f5f9;
    --text-light: #0f172a;
    --border-dark: #334155;
    --border-light: #e2e8f0;
    --shadow: 0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04);
    --shadow-lg: 0 25px 50px -12px rgba(0,0,0,0.25);
}

/* ---- GLOBAL RESET & LAYOUT ---- */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    background: var(--bg-dark);
    color: var(--text-dark);
    min-height: 100vh;
    transition: background 0.3s ease, color 0.3s ease;
    overflow-x: hidden;
}

body.light {
    background: var(--bg-light);
    color: var(--text-light);
}

/* ---- ANIMATED BACKGROUND ---- */
.bg-animation {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
    opacity: 0.05;
    pointer-events: none;
}

.bg-gradient {
    position: absolute;
    width: 500px;
    height: 500px;
    border-radius: 50%;
    filter: blur(100px);
    animation: float 20s infinite ease-in-out;
}

.bg-gradient:nth-child(1) {
    background: var(--primary);
    top: -250px;
    left: -250px;
}

.bg-gradient:nth-child(2) {
    background: var(--success);
    bottom: -250px;
    right: -250px;
    animation-delay: -10s;
}

@keyframes float {
    0%, 100% { transform: translate(0, 0) scale(1); }
    33% { transform: translate(100px, -100px) scale(1.1); }
    66% { transform: translate(-50px, 100px) scale(0.9); }
}

/* ---- CONTAINER ---- */
.container {
    max-width: 600px;
    width: 100%;
    margin: 0 auto;
    padding: 20px;
    position: relative;
    z-index: 1;
}

/* ---- HEADER ---- */
.header {
    text-align: center;
    margin-bottom: 30px;
    animation: fadeInDown 0.6s ease;
}

.theme-toggle {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    border: 2px solid var(--border-dark);
    background: var(--bg-card-dark);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    box-shadow: var(--shadow);
}

body.light .theme-toggle {
    border-color: var(--border-light);
    background: var(--bg-card-light);
}

.theme-toggle:hover {
    transform: rotate(180deg) scale(1.1);
}

.theme-toggle::before {
    content: 'üåô';
    font-size: 24px;
}

body.light .theme-toggle::before {
    content: '‚òÄÔ∏è';
}

h1 {
    font-size: clamp(28px, 5vw, 36px);
    font-weight: 700;
    background: linear-gradient(135deg, var(--primary), var(--success));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 10px;
    letter-spacing: -0.5px;
}

.subtitle {
    font-size: 16px;
    opacity: 0.7;
    font-weight: 400;
}

/* ---- INSTRUCTION CARD ---- */
.instruction-card {
    background: var(--bg-card-dark);
    border: 1px solid var(--border-dark);
    border-radius: 16px;
    padding: 20px;
    margin-bottom: 24px;
    box-shadow: var(--shadow);
    animation: fadeIn 0.6s ease 0.2s both;
    position: relative;
    overflow: hidden;
}

body.light .instruction-card {
    background: var(--bg-card-light);
    border-color: var(--border-light);
}

.instruction-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 4px;
    background: linear-gradient(90deg, var(--primary), var(--success));
}

.step-indicator {
    display: inline-block;
    background: linear-gradient(135deg, var(--primary), var(--primary-dark));
    color: white;
    padding: 6px 16px;
    border-radius: 20px;
    font-size: 14px;
    font-weight: 600;
    margin-bottom: 12px;
}

#instruction {
    font-size: 18px;
    font-weight: 500;
    line-height: 1.5;
}

#countdown {
    font-size: clamp(48px, 10vw, 72px);
    font-weight: 800;
    color: var(--success);
    margin-top: 12px;
    text-shadow: 0 0 20px rgba(16, 185, 129, 0.5);
    animation: pulse 1s ease-in-out;
}

@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

/* ---- VIDEO WRAPPER ---- */
.video-card {
    background: var(--bg-card-dark);
    border: 1px solid var(--border-dark);
    border-radius: 20px;
    padding: 16px;
    margin-bottom: 24px;
    box-shadow: var(--shadow-lg);
    animation: fadeIn 0.6s ease 0.4s both;
}

body.light .video-card {
    background: var(--bg-card-light);
    border-color: var(--border-light);
}

.video-wrapper {
    position: relative;
    width: 100%;
    border-radius: 16px;
    overflow: hidden;
    background: #000;
    box-shadow: inset 0 0 20px rgba(0,0,0,0.3);
}

video {
    width: 100%;
    height: auto;
    display: block;
    transform: scaleX(-1);
}

canvas {
    display: none;
}

/* ---- FACE DOTS ---- */
#faceDots {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    display: none;
}

.dot {
    position: absolute;
    width: 1.5px;
    height: 1.5px;
    background: rgba(255, 255, 255, 0.5);
    border-radius: 50%;
}

/* ---- FACE GUIDE OVERLAY ---- */
.face-guide {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 50%;
    height: 65%;
    max-width: 200px;
    max-height: 280px;
    pointer-events: none;
    z-index: 10;
}

.face-oval {
    position: absolute;
    width: 100%;
    height: 100%;
    border: 3px solid rgba(99, 102, 241, 0.6);
    border-radius: 50% 50% 50% 50% / 55% 55% 45% 45%;
    box-shadow: 
        0 0 0 2000px rgba(0, 0, 0, 0.4),
        inset 0 0 20px rgba(99, 102, 241, 0.3),
        0 0 30px rgba(99, 102, 241, 0.4);
    animation: guidePulse 2s ease-in-out infinite;
}

@keyframes guidePulse {
    0%, 100% { 
        border-color: rgba(99, 102, 241, 0.6);
        box-shadow: 
            0 0 0 2000px rgba(0, 0, 0, 0.4),
            inset 0 0 20px rgba(99, 102, 241, 0.3),
            0 0 30px rgba(99, 102, 241, 0.4);
    }
    50% { 
        border-color: rgba(16, 185, 129, 0.8);
        box-shadow: 
            0 0 0 2000px rgba(0, 0, 0, 0.4),
            inset 0 0 20px rgba(16, 185, 129, 0.4),
            0 0 40px rgba(16, 185, 129, 0.6);
    }
}

.guide-text {
    position: absolute;
    bottom: -40px;
    left: 50%;
    transform: translateX(-50%);
    color: white;
    font-size: 14px;
    font-weight: 600;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
    white-space: nowrap;
    background: rgba(0, 0, 0, 0.6);
    padding: 6px 12px;
    border-radius: 8px;
}

/* ---- VISUAL FEEDBACK FOR AUTO CAPTURE ---- */
.detection-indicator {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(16, 185, 129, 0.9);
    color: white;
    padding: 8px 16px;
    border-radius: 20px;
    font-size: 13px;
    font-weight: 600;
    z-index: 20;
    display: none;
    box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
}

.detection-indicator.show {
    display: block;
    animation: fadeIn 0.3s ease;
}

/* ---- TURN INSTRUCTION OVERLAY ---- */
.turn-instruction {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.85);
    color: white;
    padding: 20px 30px;
    border-radius: 16px;
    font-size: 24px;
    font-weight: 700;
    z-index: 15;
    display: none;
    text-align: center;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
    border: 2px solid rgba(99, 102, 241, 0.5);
}

.turn-instruction.show {
    display: block;
    animation: fadeIn 0.3s ease;
}

.turn-instruction .arrow {
    font-size: 48px;
    display: block;
    margin-top: 10px;
}

/* ---- BUTTONS ---- */
.button-group {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin-bottom: 24px;
    animation: fadeIn 0.6s ease 0.6s both;
}

button {
    padding: 16px 24px;
    border-radius: 12px;
    border: none;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
    box-shadow: var(--shadow);
}

button::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    border-radius: 50%;
    background: rgba(255,255,255,0.3);
    transform: translate(-50%, -50%);
    transition: width 0.6s, height 0.6s;
}

button:active::before {
    width: 300px;
    height: 300px;
}

#captureBtn {
    background: linear-gradient(135deg, var(--primary), var(--primary-dark));
    color: white;
}

#captureBtn:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 10px 25px rgba(99, 102, 241, 0.3);
}

#captureBtn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

#retakeBtn {
    background: linear-gradient(135deg, var(--danger), #dc2626);
    color: white;
}

#retakeBtn:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 25px rgba(239, 68, 68, 0.3);
}

#autoCaptureBtn {
    background: var(--bg-card-dark);
    color: var(--text-dark);
    border: 2px solid var(--border-dark);
}

body.light #autoCaptureBtn {
    background: var(--bg-card-light);
    color: var(--text-light);
    border-color: var(--border-light);
}

#autoCaptureBtn.active {
    background: linear-gradient(135deg, var(--success), #059669);
    color: white;
    border-color: var(--success);
}

#autoCaptureBtn:hover {
    transform: translateY(-2px);
}

/* ---- THUMBNAILS ---- */
#thumbs {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
    gap: 12px;
    margin-bottom: 24px;
    animation: fadeIn 0.6s ease 0.8s both;
}

.thumb {
    aspect-ratio: 4/3;
    border: 2px solid var(--border-dark);
    border-radius: 12px;
    background-size: cover;
    background-position: center;
    position: relative;
    overflow: hidden;
    transition: all 0.3s ease;
    box-shadow: var(--shadow);
}

body.light .thumb {
    border-color: var(--border-light);
}

.thumb:hover {
    transform: scale(1.05);
    box-shadow: var(--shadow-lg);
}

.thumb::after {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(16, 185, 129, 0.1));
    opacity: 0;
    transition: opacity 0.3s ease;
}

.thumb:hover::after {
    opacity: 1;
}

/* ---- UPLOAD PROGRESS ---- */
#uploadProgress {
    width: 100%;
    height: 8px;
    background: var(--bg-card-dark);
    border-radius: 4px;
    overflow: hidden;
    margin-bottom: 24px;
    display: none;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
}

body.light #uploadProgress {
    background: var(--bg-card-light);
}

#uploadProgressBar {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, var(--primary), var(--success));
    transition: width 0.3s ease;
    position: relative;
    overflow: hidden;
}

#uploadProgressBar::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
    animation: shimmer 1.5s infinite;
}

@keyframes shimmer {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
}

/* ---- RESPONSE BOX ---- */
#responseBox {
    background: var(--bg-card-dark);
    border: 1px solid var(--border-dark);
    border-radius: 16px;
    padding: 24px;
    box-shadow: var(--shadow);
    animation: fadeIn 0.6s ease 1s both;
    min-height: 100px;

    /* üî• FIX */
    display: block;
}


body.light #responseBox {
    background: var(--bg-card-light);
    border-color: var(--border-light);
}

table {
    width: 100%;
    border-collapse: separate;
    border-spacing: 0 8px;
}

th, td {
    padding: 12px;
    text-align: left;
}

th {
    background: rgba(99, 102, 241, 0.1);
    font-weight: 600;
    border-radius: 8px 0 0 8px;
}

td {
    background: rgba(99, 102, 241, 0.05);
    border-radius: 0 8px 8px 0;
}

/* ---- ANIMATIONS ---- */
@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes fadeInDown {
    from {
        opacity: 0;
        transform: translateY(-20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* ---- RESPONSIVE ---- */
@media (max-width: 640px) {
    .container {
        padding: 16px;
    }
    
    .theme-toggle {
        width: 44px;
        height: 44px;
        top: 16px;
        right: 16px;
    }
    
    .instruction-card {
        padding: 16px;
    }
    
    .video-card {
        padding: 12px;
    }
    
    button {
        padding: 14px 20px;
        font-size: 15px;
    }
    
    #responseBox {
        padding: 16px;
    }
    
    th, td {
        padding: 10px 8px;
        font-size: 14px;
    }
}

@media (max-width: 400px) {
    h1 {
        font-size: 24px;
    }
    
    .subtitle {
        font-size: 14px;
    }
    
    #instruction {
        font-size: 16px;
    }
}

/* ============================= */
/* ===== RESULT CIRCULAR UI ==== */
/* ============================= */

.results-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 18px;
    margin-top: 10px;
}

.result-circle {
    width: 120px;
    height: 120px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 0 auto;
    background: conic-gradient(
        var(--primary) 0deg,
        rgba(255,255,255,0.15) 0deg
    );
    box-shadow: var(--shadow);
}

.result-inner {
    width: 85px;
    height: 85px;
    border-radius: 50%;
    background: var(--bg-card-dark);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    font-weight: 700;
    color: var(--primary);
}

body.light .result-inner {
    background: var(--bg-card-light);
}

.result-label {
    margin-top: 6px;
    text-align: center;
    font-size: 14px;
    text-transform: capitalize;
}

/* Non-numeric values */
.text-box {
    background: rgba(15, 23, 42, 0.8);
    border-radius: 12px;
    padding: 10px 12px;
    margin-top: 8px;
    font-size: 14px;
    border: 1px solid var(--border-dark);
}

body.light .text-box {
    background: rgba(248, 250, 252, 0.9);
    border-color: var(--border-light);
}

/* Recommendations */
.recommendations-box {
    margin-top: 18px;
    padding: 14px 16px;
    border-radius: 14px;
    background: rgba(15, 23, 42, 0.9);
    border: 1px solid rgba(16, 185, 129, 0.4);
    font-size: 14px;
}

body.light .recommendations-box {
    background: #ecfdf5;
}

.recommendations-box h3 {
    margin-bottom: 6px;
    font-size: 15px;
    color: var(--success);
}

/* Continue link */
.continue-link {
    margin-top: 18px;
    text-align: center;
    font-size: 14px;
}

.continue-link a {
    color: var(--primary);
    font-weight: 600;
    text-decoration: none;
}

.continue-link a:hover {
    text-decoration: underline;
}
</style>
</head>

<body>

<div class="bg-animation">
    <div class="bg-gradient"></div>
    <div class="bg-gradient"></div>
</div>

<div class="container">

    <button class="theme-toggle" onclick="toggleDarkMode()" aria-label="Toggle theme"></button>

    <div class="header">
        <h1>OOCS AI Facial Analysis</h1>
        <p class="subtitle">This is for Demo pupose only!</p>
    </div>

    <div class="instruction-card">
        <div class="step-indicator">Step 1 of 3</div>
        <div id="instruction">Look Straight (Front Face)</div>
        <div id="countdown"></div>
    </div>

    <div class="video-card">
        <div class="video-wrapper">
            <video id="video" autoplay playsinline></video>
            <canvas id="canvas" width="640" height="480"></canvas>
            <div class="face-guide">
                <div class="face-oval"></div>
                <div class="guide-text">Position your face inside the oval</div>
            </div>
            <div class="turn-instruction" id="turnInstruction">
                <div>Look Straight</div>
                <div class="arrow">üë§</div>
            </div>
            <div class="detection-indicator" id="detectionIndicator">‚úì Pose detected! Hold still...</div>
            <div id="faceDots"></div>
        </div>
    </div>

    <div class="button-group">
        <button id="captureBtn">Capture Photo</button>
        <button id="retakeBtn" style="display:none;">‚Ü∫ Retake Photo</button>
        <button id="autoCaptureBtn">‚ö° Enable Auto Capture</button>
    </div>

    <div id="thumbs"></div>

    <div id="uploadProgress">
        <div id="uploadProgressBar"></div>
    </div>

    <div id="responseBox">
        <span style="opacity: 0.6;">Waiting for images...</span>
    </div>

</div>

<!-- SOUNDS -->
<audio id="countdownBeep" preload="auto">
    <source src="https://actions.google.com/sounds/v1/alarms/beep_short.ogg" type="audio/ogg">
</audio>
<audio id="cameraShutter" preload="auto">
    <source src="https://pixabay.com/sound-effects/camera-shutter-314056" type="audio/ogg">
</audio>

<!-- MediaPipe Face Mesh -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

<script>
/* ---------------- VARIABLES ---------------- */
let step = 1;
let images = {front: null, right: null, left: null};
let thumbURLs = {front: null, right: null, left: null};
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const faceDots = document.getElementById("faceDots");
const uploadProgress = document.getElementById("uploadProgress");
const uploadProgressBar = document.getElementById("uploadProgressBar");
const countdownBeep = document.getElementById("countdownBeep");
const cameraShutter = document.getElementById("cameraShutter");
let autoCaptureEnabled = false;
let faceMeshInstance = null;

/* ---------------- INITIALIZATION ---------------- */
document.addEventListener("DOMContentLoaded", async () => {
    await startCamera();
    startFaceMesh();
    document.getElementById("captureBtn").onclick = startCountdown;
    document.getElementById("retakeBtn").onclick = retake;
    document.getElementById("autoCaptureBtn").onclick = toggleAutoCapture;
});

/* ---------------- CAMERA ---------------- */
async function startCamera() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({
            video: { 
                width: { ideal: 1280 },
                height: { ideal: 720 },
                facingMode: "user"
            }
        });
        video.srcObject = stream;
    } catch (err) {
        console.error("Camera error:", err);
        alert("Could not access camera. Please ensure camera permissions are granted.");
    }
}

/* ---------------- DARK MODE ---------------- */
function toggleDarkMode() {
    document.body.classList.toggle("light");
}

/* ---------------- COUNTDOWN ---------------- */
function startCountdown() {
    faceDots.style.display = 'block';
    const captureBtn = document.getElementById("captureBtn");
    captureBtn.disabled = true;
    const cd = document.getElementById("countdown");
    let count = 3;
    
    function beepStep() {
        if (count > 0) {
            countdownBeep.currentTime = 0;
            countdownBeep.play().catch(err => console.log("Beep play error:", err));
            cd.innerText = count;
            cd.style.animation = 'none';
            setTimeout(() => { cd.style.animation = 'pulse 1s ease-in-out'; }, 10);
            count--;
            setTimeout(beepStep, 1000);
        } else {
            cd.innerText = '';
            capturePhoto();
        }
    }
    beepStep();
}

/* ---------------- CAPTURE PHOTO ---------------- */
function capturePhoto() {
    const ctx = canvas.getContext("2d");
    ctx.save();
    ctx.scale(-1, 1);
    ctx.drawImage(video, -canvas.width, 0, canvas.width, canvas.height);
    ctx.restore();

    // Try to play shutter sound (may fail on some browsers)
    try {
        if (cameraShutter && cameraShutter.readyState >= 2) {
            cameraShutter.currentTime = 0;
            cameraShutter.play().catch(() => {
                // Fallback: Create a simple beep using Web Audio API
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    oscillator.frequency.value = 800;
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                } catch (e) {
                    console.log("Audio playback not available");
                }
            });
        }
    } catch (e) {
        console.log("Audio error:", e);
    }

    canvas.toBlob(blob => {
        let url = URL.createObjectURL(blob);
        const stepIndicator = document.querySelector('.step-indicator');
        
        if (step === 1) {
            images.front = new File([blob], "front.jpg", {type: "image/jpeg"});
            thumbURLs.front = url;
            step = 2;
            stepIndicator.innerText = "Step 2 of 3";
            document.getElementById("instruction").innerText = "Turn RIGHT (show left side of face)";
        } else if (step === 2) {
            images.right = new File([blob], "right.jpg", {type: "image/jpeg"});
            thumbURLs.right = url;
            step = 3;
            stepIndicator.innerText = "Step 3 of 3";
            document.getElementById("instruction").innerText = "Turn LEFT (show right side of face)";
        } else if (step === 3) {
            images.left = new File([blob], "left.jpg", {type: "image/jpeg"});
            thumbURLs.left = url;
            step = 4;
            stepIndicator.innerText = "Complete";
            document.getElementById("instruction").innerText = "All images captured ‚Äî uploading...";
            uploadToAPI();
        }

        updateThumbnails();
        document.getElementById("captureBtn").disabled = false;
        document.getElementById("retakeBtn").style.display = "block";
    }, "image/jpeg", 0.95);
}

/* ---------------- RETAKE ---------------- */
function retake() {
    const stepIndicator = document.querySelector('.step-indicator');
    
    if (step === 2) {
        images.front = null;
        thumbURLs.front = null;
        step = 1;
        stepIndicator.innerText = "Step 1 of 3";
        document.getElementById("instruction").innerText = "Look Straight (Front Face)";
    } else if (step === 3) {
        images.right = null;
        thumbURLs.right = null;
        step = 2;
        stepIndicator.innerText = "Step 2 of 3";
        document.getElementById("instruction").innerText = "Turn RIGHT (show left side of face)";
    } else if (step === 4) {
        images.left = null;
        thumbURLs.left = null;
        step = 3;
        stepIndicator.innerText = "Step 3 of 3";
        document.getElementById("instruction").innerText = "Turn LEFT (show right side of face)";
    }
    updateThumbnails();
}

/* ---------------- THUMBNAILS ---------------- */
function updateThumbnails() {
    const t = document.getElementById("thumbs");
    t.innerHTML = "";
    if (thumbURLs.front) t.innerHTML += `<div class="thumb" style="background-image:url('${thumbURLs.front}')"></div>`;
    if (thumbURLs.right) t.innerHTML += `<div class="thumb" style="background-image:url('${thumbURLs.right}')"></div>`;
    if (thumbURLs.left) t.innerHTML += `<div class="thumb" style="background-image:url('${thumbURLs.left}')"></div>`;
}

/* ---------------- Fetch product image api ---------------- */
async function fetchProductImages(productList) {
    const idList = productList.map(p => ({ id: p.id }));

    const response = await fetch(
        "https://artifutech-face-ai-api-n.as.r.appspot.com/product_images",
        {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                token: "mukaz27",
                id_list: idList
            })
        }
    );

    const data = await response.json();
    return data.image_list || [];
}

/* ---------------- UPLOAD TO API ---------------- */
async function uploadToAPI() {
    uploadProgress.style.display = "block";
    uploadProgressBar.style.width = "0%";

    const fd = new FormData();
    fd.append("v", "1.2");
    fd.append("t", "mukaz27");
    fd.append("image1", images.front);
    fd.append("image2", images.right);
    fd.append("image3", images.left);

    const xhr = new XMLHttpRequest();
    xhr.open("POST", "https://artifutech-face-ai-api-n.as.r.appspot.com/api", true);

    xhr.upload.onprogress = e => {
        if (e.lengthComputable) {
            uploadProgressBar.style.width = (e.loaded / e.total * 100) + "%";
        }
    };

    xhr.onload = () => {
    uploadProgress.style.display = "none";
    document.getElementById("instruction").innerText = "‚úÖ Analysis Complete";

    let parsed;
    try {
        const raw = JSON.parse(xhr.responseText);

        if (raw && typeof raw === "object" && raw.message) {
            parsed = typeof raw.message === "string"
                ? JSON.parse(raw.message)
                : raw.message;
        } else {
            parsed = raw;
        }
    } catch (e) {
        document.getElementById("responseBox").innerHTML =
            "<span style='color: var(--danger);'>Invalid server response</span>";
        return;
    }

    const circleKeys = [
        "acne", "wrinkles", "dark_circles", "skin_texture",
        "redness", "pores", "hyperpigmentation",
        "skin_health", "sun_damage", "elasticity",
        "uneven_skin_tone", "hydration_level"
    ];

    let circlesHTML = `<div class="results-grid">`;
    let textHTML = "";
    let recHTML = "";

    Object.entries(parsed).forEach(([key, value]) => {
        if (key === "recommendations") {
            recHTML = `
                <div class="recommendations-box">
                    <h3>Recommendations</h3>
                    <p>${value}</p>
                </div>`;
            return;
        }

        if (circleKeys.includes(key)) {
            const num = Math.min(100, Math.max(0, parseInt(value) || 0));
            const angle = num * 3.6;

            circlesHTML += `
                <div>
                    <div class="result-circle"
                        style="background:conic-gradient(var(--primary) ${angle}deg, rgba(255,255,255,0.15) ${angle}deg);">
                        <div class="result-inner">${num}%</div>
                    </div>
                    <div class="result-label">${key.replace(/_/g, " ")}</div>
                </div>`;
        } else if (key === "product_recommendation" && Array.isArray(value)) {

    fetchProductImages(value).then(imageList => {

        const imageMap = {};
        imageList.forEach(img => {
            imageMap[img.id] = img.image;
        });

        let productHTML = `
            <div class="recommendations-box">
                <h3>Product Recommendations</h3>
                <ul style="list-style:none;padding:0;margin:0;">
        `;

        value.forEach(p => {
            const imgSrc = imageMap[p.id];
            const name = p.name || p.title || `Product #${p.id}`;

            productHTML += `
                <li style="display:flex;align-items:center;gap:12px;margin-bottom:12px;">
                    ${
                        imgSrc
                        ? `<img src="${imgSrc}" style="width:60px;height:60px;object-fit:contain;border-radius:8px;">`
                        : ""
                    }
                    <span>${name}</span>
                </li>
            `;
        });

        // ‚úÖ Continue link as LAST ROW
        productHTML += `
                /*<li style="margin-top:16px;text-align:center;font-size:14px;">
                    Book free service Consultation or an Appointment:
                    <a href="https://mdabzan.github.io/ai-deep/recommendations_homepage_v1.html"
                       target="_blank"
                       style="color:var(--primary);font-weight:600;text-decoration:none;">
                        Click here ‚Üí
                    </a>*/
                    <a href="https://mdabzan.github.io/ai-deep/recommendations_homepage_v1.html"
                       target="_blank"
                       style="color:var(--primary);font-weight:600;text-decoration:none;">
                        Click here ‚Üí
                    </a>
                </li>
            </ul>
        </div>`;

        document
            .getElementById("responseBox")
            .insertAdjacentHTML("beforeend", productHTML);
    });
    } else {
        textHTML += `
            <div class="text-box">
                <b>${key.replace(/_/g, " ")}:</b> ${value}
            </div>`;
    }
    });

    circlesHTML += `</div>`;

    document.getElementById("responseBox").innerHTML = `
        ${circlesHTML}
        ${textHTML}
        ${recHTML}`;
};

    xhr.onerror = () => {
        uploadProgress.style.display = "none";
        document.getElementById("instruction").innerText = "‚ùå Upload Failed";
        document.getElementById("responseBox").innerHTML = '<span style="color: var(--danger);">Upload failed. Please try again.</span>';
    };

    xhr.send(fd);
}

/* ---------------- AUTO CAPTURE ---------------- */
let autoCaptureLock = false;
let detectionFrameCount = 0;
const DETECTION_THRESHOLD = 15; // Reduced for faster response

function toggleAutoCapture() {
    autoCaptureEnabled = !autoCaptureEnabled;
    const btn = document.getElementById("autoCaptureBtn");
    const turnInstruction = document.getElementById('turnInstruction');
    const indicator = document.getElementById('detectionIndicator');
    
    btn.innerText = autoCaptureEnabled ? "‚ö° Auto Capture ON" : "‚ö° Enable Auto Capture";
    
    if (autoCaptureEnabled) {
        btn.classList.add('active');
        autoCaptureLock = false;
        detectionFrameCount = 0;
        
        // Show current step instruction
        updateTurnInstruction();
        
        console.log("‚úÖ AUTO CAPTURE ENABLED - Current step:", step);
        console.log("Waiting for face detection...");
    } else {
        btn.classList.remove('active');
        detectionFrameCount = 0;
        autoCaptureLock = false;
        
        // Hide all overlays
        turnInstruction.classList.remove('show');
        indicator.classList.remove('show');
        
        console.log("‚ùå AUTO CAPTURE DISABLED");
    }
}

function updateTurnInstruction() {
    const turnInstruction = document.getElementById('turnInstruction');
    
    if (!autoCaptureEnabled || step > 3) {
        turnInstruction.classList.remove('show');
        return;
    }
    
    if (step === 1) {
        turnInstruction.innerHTML = '<div>Look Straight</div><div class="arrow">üë§</div>';
        turnInstruction.classList.add('show');
        console.log("üì∏ Instruction: Look Straight");
    } else if (step === 2) {
        turnInstruction.innerHTML = '<div>Turn Right</div><div class="arrow">‚û°Ô∏è</div>';
        turnInstruction.classList.add('show');
        console.log("üì∏ Instruction: Turn Right");
    } else if (step === 3) {
        turnInstruction.innerHTML = '<div>Turn Left</div><div class="arrow">‚¨ÖÔ∏è</div>';
        turnInstruction.classList.add('show');
        console.log("üì∏ Instruction: Turn Left");
    }
}

function checkFaceOrientation(landmarks) {
    // Early exit if auto capture is disabled
    if (!autoCaptureEnabled) {
        return;
    }
    
    // Don't process if locked or completed
    if (autoCaptureLock || step > 3) {
        return;
    }
    
    // Get key landmarks
    const leftEye = landmarks[33];   // Left eye outer corner
    const rightEye = landmarks[263]; // Right eye outer corner
    const nose = landmarks[1];       // Nose tip
    const leftCheek = landmarks[234];
    const rightCheek = landmarks[454];
    
    // Calculate metrics
    const eyeDistance = Math.abs(rightEye.x - leftEye.x);
    const eyeMidX = (leftEye.x + rightEye.x) / 2;
    const noseX = nose.x;
    const noseOffset = noseX - eyeMidX; // How far nose is from eye center
    
    // Log every frame for debugging
    console.log(`[Step ${step}] eyeDist=${eyeDistance.toFixed(3)}, noseX=${noseX.toFixed(3)}, noseOffset=${noseOffset.toFixed(3)}, frames=${detectionFrameCount}`);
    
    let isCorrectPose = false;
    let poseName = "";
    
    // STEP 1: FRONT FACE DETECTION
    // Both eyes visible, nose centered between eyes
    if (step === 1) {
        if (eyeDistance > 0.08 && Math.abs(noseOffset) < 0.08) {
            isCorrectPose = true;
            poseName = "FRONT FACE";
        }
    }
    // STEP 2: RIGHT TURN (user's right, shows left side of face to camera)
    // Right eye less visible, nose moves left
    else if (step === 2) {
        if (noseOffset < -0.05 || noseX < 0.40) {
            isCorrectPose = true;
            poseName = "RIGHT TURN";
        }
    }
    // STEP 3: LEFT TURN (user's left, shows right side of face to camera)
    // Left eye less visible, nose moves right
    else if (step === 3) {
        if (noseOffset > 0.05 || noseX > 0.60) {
            isCorrectPose = true;
            poseName = "LEFT TURN";
        }
    }
    
    const indicator = document.getElementById('detectionIndicator');
    
    // Handle detection
    if (isCorrectPose) {
        detectionFrameCount++;
        console.log(`‚úì ${poseName} detected! Frame ${detectionFrameCount}/${DETECTION_THRESHOLD}`);
        
        // Show progress indicator
        if (detectionFrameCount > 2) {
            indicator.classList.add('show');
            const percent = Math.floor((detectionFrameCount / DETECTION_THRESHOLD) * 100);
            indicator.textContent = `‚úì ${poseName} - Hold still... ${percent}%`;
        }
        
        // Trigger capture when threshold reached
        if (detectionFrameCount >= DETECTION_THRESHOLD) {
            console.log(`üéØ ${poseName} CONFIRMED! Starting countdown...`);
            
            // Lock and reset
            autoCaptureLock = true;
            detectionFrameCount = 0;
            indicator.classList.remove('show');
            document.getElementById('turnInstruction').classList.remove('show');
            
            // Start countdown
            startCountdown();
            
            // Unlock after capture completes
            setTimeout(() => { 
                autoCaptureLock = false;
                console.log("üîì Ready for next pose - Step:", step);
                
                // Show next instruction if still enabled
                if (autoCaptureEnabled && step <= 3) {
                    updateTurnInstruction();
                }
            }, 5000);
        }
    } else {
        // Reset if pose is lost
        if (detectionFrameCount > 0) {
            console.log(`‚ùå Pose lost, resetting counter`);
            detectionFrameCount = 0;
            indicator.classList.remove('show');
        }
    }
}

/* ---------------- MEDIAPIPE FACE MESH ---------------- */
function startFaceMesh() {
    faceMeshInstance = new FaceMesh({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
    });
    
    faceMeshInstance.setOptions({
        maxNumFaces: 1,
        refineLandmarks: true,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
    });

    faceMeshInstance.onResults(results => {
        faceDots.innerHTML = "";
        
        if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
            const landmarks = results.multiFaceLandmarks[0];
            const vw = video.offsetWidth;
            const vh = video.offsetHeight;
            
            landmarks.forEach(pt => {
                const x = (1 - pt.x) * vw;
                const y = pt.y * vh;
                const dot = document.createElement("div");
                dot.className = "dot";
                dot.style.left = x + "px";
                dot.style.top = y + "px";
                faceDots.appendChild(dot);
            });
            
            faceDots.style.display = "block";

            // <-- REPLACED IMMEDIATE CAPTURE WITH FRAME-BASED CHECK
            // Call the orientation check so your DETECTION_THRESHOLD/frame counting logic runs.
            checkFaceOrientation(landmarks);
        } else {
            faceDots.style.display = "none";
        }
    });

    const camera = new Camera(video, {
        onFrame: async () => {
            await faceMeshInstance.send({image: video});
        },
        width: 640,
        height: 480
    });
    camera.start();
}
</script>

</body>
</html>
